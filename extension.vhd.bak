-- Quartus II VHDL Template
-- Four-State Moore State Machine

-- A Moore machine's outputs are dependent only on the current state.
-- The output is written only when the state changes.  (State
-- transitions are synchronous.)

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;  -- defines the unsigned type

entity lights is

	port(
		clk		 : in	std_logic;
		reset	    : in	std_logic;
		lightsig	 : out	std_logic_vector(7 downto 0);  -- output signal that will drive the LED display on the board
		IRView	 : out	std_logic_vector(2 downto 0);  -- IR and PC will let you monitor the values of the IR and PC registers.
		PCView    : out unsigned (3 downto 0)
	);

end entity;

architecture rtl of lights is
	-- uncomment the following section if lightrom
	--component lightrom
		--port(
			--addr	   : in std_logic_vector (3 downto 0);
			--data   : out std_logic_vector(2 downto 0)
		--);
	--end component;
	
	-- uncomment the following secntion if lightromMyprog
	--component lightromMyprog
		--port(
			--addr	 : in std_logic_vector (3 downto 0);
			--data   : out std_logic_vector(2 downto 0)
		--);
	--end component;
	
	-- uncomment the following secntion if lightrom2Myprog
	component lightrom2Myprog
		port(
			addr	 : in std_logic_vector (3 downto 0);
			data   : out std_logic_vector(2 downto 0)
		);
	end component;

	-- Build an enumerated type for the state machine
	type state_type is (sFetch, sExecute);
	signal IR  : std_logic_vector(2 downto 0);
	signal PC  : unsigned(3 downto 0);
	signal LR  : unsigned (7 downto 0);
	signal ROMvalue  : std_logic_vector(2 downto 0);
	signal state   : state_type;

begin

	-- Logic to advance to the next state
	process (clk, reset)
	begin
		if reset = '0' then
			state <= sFetch;
			IR <= "000";
			PC <= "0000";
			LR <= "00000000";
			
		elsif (rising_edge(clk)) then
			case state is
				when sFetch=>
					IR <= ROMValue;
					PC <= PC + 1;
					state <= sExecute;
				when sExecute=>
					case IR is
						when "000" =>
							LR <= "00000000";
						when "101" =>
							LR <= NOT LR;
						when "001" =>
							LR <= '0' & LR(7 downto 1);
						when "111" =>
							LR <= LR(6 downto 0) & LR(7);
						when "010" =>
							LR <= LR(6 downto 0) & '0';
						when "011" =>
							LR <= LR + 1;
						when "100" => 
							LR <= LR - 1;
						when others =>
							LR <= (others => '0');
					end case;
					state <= sFetch;
			end case;
		end if;
	end process;

	-- Output depends solely on the current state
	
	lightsig <= std_logic_vector(LR);
	IRView <= IR;
	PCView <= PC;
	
	-- Uncomment below section if lightrom
	--lightrom1 : lightrom
		--port map ( 
			--addr => std_logic_vector(PC), 
			--data => ROMValue
		--);
		
	-- Uncomment below section if lightromMyprog
	--lightromMyprog1 : lightromMyprog
		--port map ( 
			--addr => std_logic_vector(PC), 
			--data => ROMValue
		--);
		
	-- Uncomment below section if lightrom2Myprog
	lightrom2Myprog1 : lightrom2Myprog
		port map ( 
			addr => std_logic_vector(PC), 
			data => ROMValue
		);


	
end rtl;
